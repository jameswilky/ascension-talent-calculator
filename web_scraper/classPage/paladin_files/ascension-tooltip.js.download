class TooltipOptions {
    constructor() {
        this.detectInlineLinks = false;
        this.detectInlineLinksLive = false;
        this.detectInlineLinksLiveInterval = 10000;
        this.inlineLinksParentDataAttribute = "data-ascension-inline-links";
        this.inlineLinksParentExcludeDataAttribute = "data-ascension-inline-links-exclude";
        this.inlineLinkRegexPattern = /\[.*?\]/g;
        this.inlineLinkClass = "ascension-tooltip-target";
        this.inlineLinkAddImage = true;
        this.defaultImage = "/files/images/icons/INV_Misc_QuestionMark.png";
        this.enableTooltips = true;
        this.tooltipTypeDataAttribute = "data-ascension-tooltip-type";
        this.tooltipIDDataAttribute = "data-ascension-tooltip-id";
        this.tooltipYOffset = 5;
        this.tooltipClassName = "ascension-tooltip-container";
        this.apiUrl = "https://data.project-ascension.com/";
    }
}
class AscensionTooltips {
    constructor(options = new TooltipOptions()) {
        this.options = options;
        this.tooltipRequireContentFetch = "data-ascension-tooltip-content-fetch";
        this.currentObserver = null;
        this.currentTarget = null;
        this.loadTooltipContentCache = {};
        this.contentForSpellCache = {};
        this.options = Object.assign(new TooltipOptions(), options);
        if (window.document.readyState != "loading") {
            this.onDocumentDOMContentLoaded(null);
        }
        else {
            window.addEventListener("load", (e) => { this.onDocumentDOMContentLoaded(e); });
        }
    }
    onDocumentDOMContentLoaded(e) {
        if (this.options.detectInlineLinks) {
            this.setupInlineLinks();
        }
        this.setupContentFetch();
        window.document.body.addEventListener("mouseout", (e) => { this.onDocumentMouseOut(e); }, false);
        window.document.body.addEventListener("mouseover", (e) => { this.onDocumentMouseOver(e); }, false);
    }
    onDocumentMouseOver(e) {
        if (e == null || e.target instanceof Element == false)
            return;
        let target = e.target;
        if (!target.hasAttribute(this.options.tooltipTypeDataAttribute))
            return;
        if (target == this.currentTarget)
            return;
        this.currentTarget = target;
        this._setupObserver(this.currentTarget);
        let type = target.getAttribute(this.options.tooltipTypeDataAttribute);
        if (type == "spell") {
            if (!target.hasAttribute(this.options.tooltipIDDataAttribute))
                return;
            let tooltip = document.createElement("div");
            tooltip.className = this.options.tooltipClassName;
            tooltip.innerHTML = "Loading...";
            window.document.body.appendChild(tooltip);
            this._tooltipPosition(target, tooltip);
            this._loadTooltipContent(target, tooltip, +target.getAttribute(this.options.tooltipIDDataAttribute));
        }
    }
    _setupObserver(target) {
        this._cancelObserver();
        this.currentObserver = new MutationObserver((mutation) => {
            let nodes = window.document.querySelector("." + this.options.tooltipClassName);
            if (nodes != null) {
                window.document.body.removeChild(nodes);
                this.currentTarget = null;
            }
            if (!target.hasAttribute(this.options.tooltipIDDataAttribute))
                return;
            let tooltip = document.createElement("div");
            tooltip.className = this.options.tooltipClassName;
            tooltip.innerHTML = "Loading...";
            window.document.body.appendChild(tooltip);
            this._tooltipPosition(target, tooltip);
            this._loadTooltipContent(target, tooltip, +target.getAttribute(this.options.tooltipIDDataAttribute));
        });
        this.currentObserver.observe(target, { attributes: true });
    }
    _cancelObserver() {
        if (this.currentObserver != null) {
            this.currentObserver.disconnect();
        }
    }
    onDocumentMouseOut(e) {
        if (e == null || e.target instanceof Element == false)
            return;
        let target = e.target;
        if (!target.hasAttribute(this.options.tooltipTypeDataAttribute))
            return;
        this._cancelObserver();
        let nodes = window.document.querySelectorAll("." + this.options.tooltipClassName);
        for (let i = 0; i < nodes.length; i++) {
            let node = nodes[i];
            if (nodes != null) {
                window.document.body.removeChild(node);
                this.currentTarget = null;
            }
        }
    }
    _tooltipPosition(parent, tooltip) {
        let parentCoords = parent.getBoundingClientRect();
        let left = parseInt(parentCoords.left) + ((parent.offsetWidth - tooltip.offsetWidth) / 2);
        let top = parseInt(parentCoords.top) - tooltip.offsetHeight - this.options.tooltipYOffset;
        left = (left < 0) ? parseInt(parentCoords.left) : left;
        top = (top < 0) ? parseInt(parentCoords.bottom) + this.options.tooltipYOffset : top;
        tooltip.style.left = left + "px";
        tooltip.style.top = top + pageYOffset + "px";
    }
    _loadTooltipContent(parent, element, id) {
        if (this.loadTooltipContentCache[id] != null) {
            Promise.resolve(this.loadTooltipContentCache[id]).then((res) => {
                this._loadTooltipContentOnRes(parent, element, res);
            });
            return;
        }
        this.loadTooltipContentCache[id] = fetch(this.options.apiUrl + "api/spells/" + (+id) + "/tooltip.html").then((res) => {
            if (res.ok == false) {
                return res.json();
            }
            return res.text();
        })
            .then((res) => {
            if (res.message != null) {
                res = res.message;
            }
            this.loadTooltipContentCache[id] = res;
            this._loadTooltipContentOnRes(parent, element, res);
            return res;
        });
        this.loadTooltipContentCache[id].catch((err) => {
            if (element != null) {
                window.document.body.removeChild(element);
                let tooltip = document.createElement("div");
                tooltip.className = this.options.tooltipClassName;
                tooltip.innerHTML = `Error while loading tooltip for spell with ID ${id}`;
                window.document.body.appendChild(tooltip);
                this._tooltipPosition(parent, tooltip);
            }
            this._log(err.message);
        });
    }
    _loadTooltipContentOnRes(parent, element, res) {
        if (element != null) {
            window.document.body.removeChild(element);
            let tooltip = document.createElement("div");
            tooltip.className = this.options.tooltipClassName;
            tooltip.innerHTML = res;
            window.document.body.appendChild(tooltip);
            this._tooltipPosition(parent, tooltip);
        }
    }
    setupInlineLinks() {
        let inlineLinkParents = this._getAllElementsWithAttribute(this.options.inlineLinksParentDataAttribute);
        for (let i = 0; i < inlineLinkParents.length; i++) {
            this._setupInlineLinksRec(inlineLinkParents[i]);
        }
        if (this.options.detectInlineLinksLive) {
            setTimeout(this.setupInlineLinks.bind(this), this.options.detectInlineLinksLiveInterval);
        }
    }
    _setupInlineLinksRec(node) {
        for (let i = 0; i < node.children.length; i++) {
            if (node.hasAttribute(this.options.inlineLinksParentExcludeDataAttribute)) {
                return;
            }
            let child = node.children[i];
            this._setupInlineLinksRec(child);
            if (child.innerHTML != null && child.nodeType == 1) {
                if (this.options.inlineLinkRegexPattern.test(child.innerHTML)) {
                    child.innerHTML = child.innerHTML.replace(this.options.inlineLinkRegexPattern, (match, contents, offset) => {
                        let sliced = match.slice(1, -1);
                        let split = sliced.split(';');
                        if (split.length == 3) {
                            if (split[0] == "tooltip") {
                                let image = "";
                                if (this.options.inlineLinkAddImage) {
                                    image = `<img style="height: 1em" src="${this.options.apiUrl + this.options.defaultImage}">`;
                                }
                                return `<a class="${this.options.inlineLinkClass}" style="color: gray" ${this.tooltipRequireContentFetch} ${this.options.tooltipTypeDataAttribute}="${split[1]}" ${this.options.tooltipIDDataAttribute}="${split[2]}">${image}[Loading...]</a>`;
                            }
                        }
                        return match;
                    });
                }
            }
        }
    }
    setupContentFetch() {
        let elements = this._getAllElementsWithAttribute(this.tooltipRequireContentFetch);
        for (let i = 0; i < elements.length; i++) {
            let type = elements[i].getAttribute(this.options.tooltipTypeDataAttribute);
            if (type == "spell") {
                this._getContentForSpell(elements[i]);
            }
        }
    }
    _getContentForSpell(element) {
        let id = element.getAttribute(this.options.tooltipIDDataAttribute);
        if (this.contentForSpellCache[id] != null) {
            this.contentForSpellCache[id].then((res) => {
                this._getContentForSpellOnRes(element, res);
            });
            return;
        }
        this.contentForSpellCache[id] = fetch(this.options.apiUrl + "spells/" + (+id) + "/tooltip").then((res) => {
            return res.json();
        }).then((res) => {
            this._getContentForSpellOnRes(element, res);
            return res;
        });
        this.contentForSpellCache[id].catch((err) => {
            element.innerHTML = `[Error while loading spell content with ID ${id}]`;
            this._log(err.message);
        });
    }
    _getContentForSpellOnRes(element, res) {
        if (res.status == null) {
            if (res.colorCode == null)
                res.colorCode = "gray";
            let image = "";
            if (this.options.inlineLinkAddImage) {
                let imageUrl = res.imageUrl;
                if (imageUrl == null)
                    imageUrl = this.options.defaultImage;
                image = `<img style="height: 1em" src="${this.options.apiUrl + imageUrl.substring(1)}">`;
            }
            element.setAttribute("style", "color: " + res.colorCode);
            element.innerHTML = `${image}[${res.name}]`;
        }
        else {
            throw new Error(res.message);
        }
    }
    _getAllElementsWithAttribute(attribute) {
        let matching = [];
        let allElements = window.document.getElementsByTagName("*");
        for (let i = 0; i < allElements.length; i++) {
            if (allElements[i].hasAttribute(attribute)) {
                matching.push(allElements[i]);
            }
        }
        return matching;
    }
    _log(msg) {
        console.log("[ASCENSION-TOOLTIP] " + msg);
    }
}
//# sourceMappingURL=ascension-tooltip.js.map